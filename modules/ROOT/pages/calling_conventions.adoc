= Calling Conventions
:description: Examples of calling conventions on common platforms
:keywords: assembly, x86, x64, sysv, msvc
:page-category: Assembly
:source-language: c

== What are calling conventions?
A calling convention is the set of contracts that compiler-generated machine code respects and expects external functions to respect. The calling convention specifies, for example

- how parameters are passed to functions
- how the stack is handled and cleaned (for example if needs to be aligned at function entry)
- how structures are going to be laid out in memory
- which registers need to be restored by the caller and which by the callee

== x86-64 calling conventions
The Windows (including UEFI) world and the UNIX (Linux, macOS, BSDs) world have adopted two different conventions. Note that MSVC can only generate code using the Windows calling convention.

=== Microsoft x64footnote:[https://github.com/MicrosoftDocs/cpp-docs/blob/main/docs/build/x64-calling-convention.md]

> The x64 Application Binary Interface (ABI) uses a four-register fast-call calling convention by default. Space is allocated on the call stack as a shadow store for callees to save those registers.

> There's a strict one-to-one correspondence between a function call's arguments and the registers used for those arguments. Any argument that doesn't fit in 8 bytes, or isn't 1, 2, 4, or 8 bytes, must be passed by reference. A single argument is never spread across multiple registers.

> The x87 register stack is unused. It may be used by the callee, but consider it volatile across function calls. All floating point operations are done using the 16 XMM registers.

> Integer arguments are passed in registers RCX, RDX, R8, and R9. Floating point arguments are passed in XMM0L, XMM1L, XMM2L, and XMM3L. 16-byte arguments are passed by reference. Parameter passing is described in detail in Parameter passing. These registers, and RAX, R10, R11, XMM4, and XMM5, are considered volatile.

==== Register allocation

Caller-saved: RAX, RCX, RDX,  R8, R9, R10, R11

Callee-saved: RBX, RBP, RDI, RSI, RSP, R12, R13, R14, R15

==== Stack
The stack is always 16-byte aligned at function **entry**: this requires the stack to be **NOT** aligned to 16 bytes before the `CALL`, since the instruction pushes 8 bytes on the stack.

All functions need to have 32 bytes of home space (also known as spill space or shadow space), which is allocated *before* pushing the other parameters on the stack. This allows for an easier implementation of variadic functions: `va_start` can just put the four register parameters in the home space such that `va_arg` simply becomes a lookup starting at RSP.

For example, if the caller calls a function with 4 or 5 arguments, it needs to allocate 40 bytes of stack in order for the stack at the callee entry to be 48 bytes below the caller's stack.


==== Parameters
`RCX`/`XMM0`, `RDX`/`XMM1`, `R8`/`XMM2`, `R9`/`XMM3`, stack (`[RSP+0x20]`, `[RSP+0x28]` and so on, 0x20 is due to the home space being there).

For example, a function with the prototype 

[source,c]
----
 void DoSomething(int a, float b, int c, int d, int e, float f);
----

would pass parameters in RCX, XMM1, R8, R9, [RSP+0x20] and [RSP+0x28] respectively. A function calling this needs to have at least 56 bytes of stack to store the parameters and home space and ensure that the stack is aligned after the `CALL`.

==== Return value
If the return value is an integer/struct/union whose size is less than or equal than 64 bits, it's returned in RAX; otherwise, the struct is allocated by the caller and a pointer to it is passed as the first parameter.

`LargeStruct DoSomething(int a)` 
actually becomes 
`void DoSomething(LargeStruct *ret, int a)`.

=== System Vfootnote:[https://raw.githubusercontent.com/wiki/hjl-tools/x86-psABI/x86-64-psABI-1.0.pdf]

> The standard calling sequence requirements apply only to global functions. Local functions that are not reachable from other compilation units may use different conventions. Nevertheless, it is recommended that all functions use the standard calling sequence when possible.

> The CPU shall be in x87 mode upon entry to a function. Therefore, every function that uses the MMX registers is required to issue an EMMS or FEMMS instruction after using MMX registers, before returning or calling another function.

> The direction flag DF in the RFLAGS register must be clear (set to “forward” direction) on function entry and return. Other user flags have no specified role in the standard calling sequence and are not preserved across calls.

> Registers RBP, RBX and
R12 through R15 “belong” to the calling function and the called function is required to preserve their values. In other words, a called function must preserve these registers’ values for its caller. Remaining registers “belong” to the called function.

==== Register allocation

Caller-saved: RAX, RCX, RDX, RDI, RSI, R8, R9, R10, R11

Callee-saved: RBX, RBP, RSP R12, R13, R14, R15

==== Stack
The stack is always 16-byte aligned at function **call**: this requires the stack to be aligned to 16 bytes before the `CALL`. The push of the return address onto the stack by `CALL` is immediately succeeded by the push of RBP onto the stack by the callee function, thereby re-aligning the stack shortly after function entry.

==== Parameters
`RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9`, stack (`[RSP+0x00]`, `[RSP+0x08]` and so on).

If the parameter is of type `float` or `double`, it will be stored in the next available SSE register (`XMM0`-`XMM7`).

For example, a function with the prototype `void DoSomething(int a, float b, int c, int d, int e, float f)` would pass parameters in `RDI`, `XMM0`, `R8`, `R9`, `[RSP+0x00]` and `XMM1` respectively. A function calling this needs to have at least 32 bytes of stack to store the parameters and align the stack upon call.

==== Return value
If the return value is an integer/struct/union whose size is less than or equal than 64 bits, it's returned in `RAX`; otherwise, the struct is allocated by the caller and a pointer to it is passed as the first parameter, similarly to the Microsoft x64 ABI. Dissimilarly, the pointer is actually returned in `RAX` upon return.

`LargeStruct DoSomething(int a)`
actually becomes 
`LargeStruct* DoSomething(LargeStruct *ret, int a)`.

== S/390 calling conventions
The S/390 offers a limited and partially undocumented set of calling conventions.

=== "MVS"
> The stack pointer is passed via R1
> "Base" register (this is, the register used for instructions as the base-displacement operand) is R12
> R15 is the return value

An example stub function is shown belown:

```hlasm
         CSECT
*
* Diag 8
* IN:
*    pointer to EBCDIC message
*    length
         ENTRY @@DIAG8
@@DIAG8  DS 0H
* This will save non-clobbered registers into the stack
         SAVE (14,12),,@@DIAG8
* Base register would have a relative address to @@DIAG8
* so any LOAD operation that takes place is then given an
* access address of BASE+ADDR; this is required because
* S/390 does not offer many instructions that address above
* the 12-bit limit.
         LR 12,15
* From this point the R12 register is "allocated" (and later dropped)
         USING @@DIAG8,12
         LR 11,1
* Pointer to message loaded on R1
         L 1,0(11)
* Length loaded on R2
         L 2,4(11)
* DIAG is not supported by MVS3.8J HLASM
* so we have to define it manually
*         DIAG 1,2,8
         DC X'83120008'
* Set our return value to 0
         L 15,0
* Return and restore 14,12, the return code is on R15
         RETURN (14,12),RC=(15)
* Organize for data section (usually in MVS data and code are mixed together)
         LTORG
* We free up our base register so other procedure can use it
         DROP 12
		 END
```

On a bare-metal situation the GCCMVS compiler will expect stack+76 to have a pointer to the next stack frame.

In said case one has simply to do the very simple task of:

```hlasm
		 CSECT
* Symbol declarations
		 ENTRY KEINIT
         ENTRY SETSTACK
SETSTACK DS 0H
         BALR 12,0
* Base register R12 will be based at this precise address
* the asterisk denotes the current address
         USING *,12
* Set the stack pointer
         L 13,=A(@@STACK)
* Load the address of 180(13), this is, calculate R13+180, then
* put said value into R5
         LA 5,180(13)
* Now the value we calculated is then put onto R13[76] where GCCMVS
* expects it to be
         ST 5,76(13)
* Jump to the C-code expected to be loaded (=V is for external symbols)
         L 15,=V(KEINIT)
         BR 15
* Properly prepare for data section and deallocate our base register
		 LTORG
         DROP 12
		 END
```

=== See Also

